# Design Pattern 연습

## 명심하자!
항상 코드는 DRY하고 KISS하고 YAGNI하게..

DRY = Don't Repeat Yourself     - 특정 코드의 로직이 다양한 곳에서 반복되어 사용하지 마라.\
KISS = Keep In Simple, Stupid   - 코드는 항상 심플하고 멍청하게. 그리고 누구나 알아볼수 있게.\
YAGNI = You Ain't Gonna Need It - 지금 당장 필요없는 것을 미리 만들지 말자.

---------------------------------------------------------------

## Last Update

## 2022.01.24 (월)

1. 싱글턴 패턴

오직 한개의 클래스 인스턴스(static)만 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공한다.
- 일종의 전역변수. 모든 곳에서 접근 가능하여 공유할 수 있는 단 하나의 인스턴스.

- **단점**
전역 변수이므로 전역변수가 가지는 모든 장단점을 다 가지고 있음. 쓰면 안된다는게 아니라 이런 단점을 가지고 있으니
사용에 주의하자.
	- 모든 곳에서 접근이 가능하므로 싱글톤 객체의 변경 시점, 변경 주체, 호출 시점을 모두 알기가 어렵다.
	- **여러 클래스와 커플링이 된다**. 즉 하나의 코드를 수정했을 때, 싱글톤과 연결된 다양한 곳에서 문제가 발생.
	- **멀티쓰레드 환경에서 문제 발생**. 모든 곳에서 접근이 가능하기 때문에 race condition이 발생. 이를 막기 위해 싱글톤은 mutex lock과 unlock을 반복적으로 걸기 때문에, 코드의 성능은 떨어지게 된다.

- 유니티에서는 여러 오브젝트들이 데이터를 사용하는 오브젝트를 단 한개를 만들어두고 이를 공유한다.

	- 같은 Scene 안에서의 데이터 공유시에 사용된다.
	- 서로 다른 Scene들간의 데이터 공유시에 사용된다. DontDestroyOnLoad 메소드를 호출하여 Scene 변경시에도 싱글톤 객체의 Destroy를 막아주는 형태로 구현한다.


------------------------------------------------------

## 이전 개발 일지

### 2022.01.23 (일)

1. 컴포넌트 패턴 - 상속 vs 컴포넌트

- 상속 : A is B

	- 부모 클래스로 부터 물려받은 부분은 다시 쓸 필요가 없기 때문에, 재사용 면에 있어서 효율적.
	- 부모 클래스가 될 공통된 필수 집합들을 개발자가 미리 예상하기가 힘들다.
	- 컴포넌트들끼리 커플링이 심하다. 만약 부모 클래스가 삭제 당하면 나머지 자식 클래스들에게 치명적인 문제들이 생긴다.
	
	Ex) 고블린은 몬스터이다. Is-A의 관계이므로 상속으로 만들어야한다.


- 컴포넌트 : A has B
	빈 컨테이너에 필요할 때 마다 원하는 기능을 갖다 붙여 포함시키는 방식. 일명 **부품**

	- 각자의 기능을 가지고 있는 스스로 동작하는 독립적인 부품.
	- 독립적인 클래스를 만들어 두고 만들어 둔 부품을 부품 붙이듯이 갖다 붙이면 된다.
	- 컴포넌트를 뗀다고 해서 오브젝트의 다른 컴포넌트에 영향이 가는 것은 없다. 가장 큰 장점
	- 코드의 의존성을 줄이고 재사용성을 높인다.

	Ex) 플레이어는 스테이터스를 가진다. Has-A의 관계. 컴포넌트로 구현하는 것이 좋다.

	- 그야말로 **유니티에서의 컴포넌트 동작 원리**


### 2022.01.21 (금)

1. 레포지토리 생성 및 디자인 패턴의 시작

모든 디자인 패턴의 시작 => 하위 클래스를 상위 클래스 객체에 대입할 수 있다.
**다형성**이 핵심

```C#
Superclass obj = new Subclass();
/**********************************************/
Superclass obj1 = new Superclass();
Subclass obj2 = obj1;   // 컴파일 에러
```
- 부모 객체에 자식 클래스를 대입할 수 **있다.**
- 반대로 자식 객체에 부모 클래스를 대입할 수 **없다.**
- 이때 **obj**는 Subclass 타입의 객체를 참조하고 있지만, Superclass가 물려준 멤버들만 호출할 수 있다.
- Subclass만의 멤버들은 호출할 수 없다.
- 상위 클래스 객체를 하위 클래스에 대입할 수 없다.

부모 타입 포인터로 자식 객체를 참조했을 때 각 자식의 오버라이딩 된 멤버 함수를 호출하게 하려면 그 멤버 함수를 가상 함수(**virtual**)로 정의해야 한다.