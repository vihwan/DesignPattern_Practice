# Design Pattern 연습

## 명심하자!
항상 코드는 DRY하고 KISS하고 YAGNI하게..

DRY = Don't Repeat Yourself     - 특정 코드의 로직이 다양한 곳에서 반복되어 사용하지 마라.\
KISS = Keep In Simple, Stupid   - 코드는 항상 심플하고 멍청하게. 그리고 누구나 알아볼수 있게.\
YAGNI = You Ain't Gonna Need It - 지금 당장 필요없는 것을 미리 만들지 말자.

---------------------------------------------------------------

## Last Update

## 2022.02.14 (월)

1. 싱글턴 패턴 4 - Lazy<T>를 이용한 구현



------------------------------------------------------

## 이전 개발 일지

### 2022.02.03 (목)

1. 싱글턴 패턴 3 - Lazy<T>

지난번에 lock을 이용하여 싱글톤을 구현. 동기화 처리를 잘못하면 게임 도중 GameManager와 같은 객체가 두개가 생성될 수 있다. lock(object)을 이용하면, object가 다른 스레드에서 사용 중이면 사용이 끝날 때까지 해당 스레드를 기다리게 할 수 있다.

**싱글턴 컴포넌트가 아직 없을 때는, if (!_instance) 다음에 lock 구문을 거쳐서 스레드 간의 병행성이 보장이 된다.**
**그런데 싱글턴 컴포넌트가 이미 생성된 상태에서 멀티 스레드가 동시에 접근한다면, 데이터를 변경할 때 제대로 적용되지 않는 병행성 이슈가 발생하게 된다.**
**생명력을 나타내는 Life 변수가 있을 때, 두 쓰레드가 동시에 Life를 감소시키려고 한다면 하나의 쓰레드의 연산만 적용되는 경우가 생길 수 있다는 것이다.**
**아예 병행성 문제를 없애려면, 싱글턴 컴포넌트를 호출할 때마다 lock을 걸거나, 그 아래의 변수를 수정할 때마다 lock을 거는 수밖에 없다.**
**다만 lock은 한 스레드 외의 스레드가 이용할 수 없게 만들다 보니 성능을 저하시킨다. 또, 데드락 문제를 발생시켜서 아예 프로그램을 정지시켜버릴 수 있으니 주의해야 한다.**


위의 문제를 해결하기 위해서 Lazy<T>(Thread Safe)를 사용하여 구현할 수도 있다.
Lazy<T>는 초기화를 지연시켜서 접근하려고 하면 그때 객체를 생성하는 클래스이다.

Lazy 클래스는 세 가지 경우에 유용하다.
- 생성이 오래걸리는 큰 오브젝트를 필요할 때만 생성할 때
- 리소스를 많이 사용하는 실행을 필요할 때만 할 때
- 자원 생성을 멀티 쓰레드 환경에서 안전하게 해야할 때

즉, Lazy는 멀티 쓰레드에서도 안전하기 때문에, lock 대신에 활용할 수 있다.

MonoBehavior를 이용하여 게임 오브젝트를 만든다면 다음과 같이 만들 수 있을 것이다.
```C#
private static readonly Lazy<T> _instance = 
        new Lazy<T>(()=>{
            T instance = FindObjectOfType(typeof(T)) as T;
            if(instance == null)
            {
                GameObject obj = new GameObject("GameManagers");
                instance = obj.AddComponent(typeof(T)) as T;
                DontDestroyOnLoad(obj);
            }
            return instance;
        });
```


### 2022.01.28 (금)

1. 싱글턴 패턴 2

싱글톤 패턴은 왜 사용하는가?

- 오직 하나의 인스턴스만 갖도록 보장
- 전역 접근성을 제공
- 한 번도 사용하지 않는다면 아예, 메모리조차 할당하지 않을 수 있음
- 런타임에 초기화된다. 정적 멤버 변수는 컴파일 타임에 자동으로 초기화가 되는 문제가 있지만, 싱글턴은 최대한 늦게 필요한 시점에서 초기화를 시킬 수 있기 때문에, 해당 시점에는 싱글톤이 필요하는 정보를 안전하게 가져올 수 있고, 순환 참조의 문제만 없다면 다른 싱글톤끼리의 참조또한 어렵지 않습니다.
- 싱글톤을 상속할 수 있다. 싱글톤 코드는 구현이 어느정도 고정되어 있으므로, 여러가지 관리자 클래스가 필요할때 하나의 싱글톤 부모 클래스를 상속함으로서 구현상의 생산성을 증대시킬 수 있다.


싱글톤에서 벌어지는 여러가지 문제를 고려하는 방법
1) 동기화에 대한 예외처리
2) 클래스만 있고 씬에서 해당 클래스 오브젝트가 없을때의 예외처리
3) DonDontDestroyOnLoad로 인해 씬이 재시작 되면 생기는 2개의 오브젝트 문제
4) 비대해진 코드를 압축하는 방법


### 2022.01.24 (월)

1. 싱글턴 패턴

오직 한개의 클래스 인스턴스(static)만 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공한다.
- 일종의 전역변수. 모든 곳에서 접근 가능하여 공유할 수 있는 단 하나의 인스턴스.

- **단점**
전역 변수이므로 전역변수가 가지는 모든 장단점을 다 가지고 있음. 쓰면 안된다는게 아니라 이런 단점을 가지고 있으니
사용에 주의하자.
	- 모든 곳에서 접근이 가능하므로 싱글톤 객체의 변경 시점, 변경 주체, 호출 시점을 모두 알기가 어렵다.
	- **여러 클래스와 커플링이 된다**. 즉 하나의 코드를 수정했을 때, 싱글톤과 연결된 다양한 곳에서 문제가 발생.
	- **멀티쓰레드 환경에서 문제 발생**. 모든 곳에서 접근이 가능하기 때문에 race condition이 발생. 이를 막기 위해 싱글톤은 mutex lock과 unlock을 반복적으로 걸기 때문에, 코드의 성능은 떨어지게 된다.

- 유니티에서는 여러 오브젝트들이 데이터를 사용하는 오브젝트를 단 한개를 만들어두고 이를 공유한다.

	- 같은 Scene 안에서의 데이터 공유시에 사용된다.
	- 서로 다른 Scene들간의 데이터 공유시에 사용된다. DontDestroyOnLoad 메소드를 호출하여 Scene 변경시에도 싱글톤 객체의 Destroy를 막아주는 형태로 구현한다.


### 2022.01.23 (일)

1. 컴포넌트 패턴 - 상속 vs 컴포넌트

- 상속 : A is B

	- 부모 클래스로 부터 물려받은 부분은 다시 쓸 필요가 없기 때문에, 재사용 면에 있어서 효율적.
	- 부모 클래스가 될 공통된 필수 집합들을 개발자가 미리 예상하기가 힘들다.
	- 컴포넌트들끼리 커플링이 심하다. 만약 부모 클래스가 삭제 당하면 나머지 자식 클래스들에게 치명적인 문제들이 생긴다.
	
	Ex) 고블린은 몬스터이다. Is-A의 관계이므로 상속으로 만들어야한다.


- 컴포넌트 : A has B
	빈 컨테이너에 필요할 때 마다 원하는 기능을 갖다 붙여 포함시키는 방식. 일명 **부품**

	- 각자의 기능을 가지고 있는 스스로 동작하는 독립적인 부품.
	- 독립적인 클래스를 만들어 두고 만들어 둔 부품을 부품 붙이듯이 갖다 붙이면 된다.
	- 컴포넌트를 뗀다고 해서 오브젝트의 다른 컴포넌트에 영향이 가는 것은 없다. 가장 큰 장점
	- 코드의 의존성을 줄이고 재사용성을 높인다.

	Ex) 플레이어는 스테이터스를 가진다. Has-A의 관계. 컴포넌트로 구현하는 것이 좋다.

	- 그야말로 **유니티에서의 컴포넌트 동작 원리**


### 2022.01.21 (금)

1. 레포지토리 생성 및 디자인 패턴의 시작

모든 디자인 패턴의 시작 => 하위 클래스를 상위 클래스 객체에 대입할 수 있다.
**다형성**이 핵심

```C#
Superclass obj = new Subclass();
/**********************************************/
Superclass obj1 = new Superclass();
Subclass obj2 = obj1;   // 컴파일 에러
```
- 부모 객체에 자식 클래스를 대입할 수 **있다.**
- 반대로 자식 객체에 부모 클래스를 대입할 수 **없다.**
- 이때 **obj**는 Subclass 타입의 객체를 참조하고 있지만, Superclass가 물려준 멤버들만 호출할 수 있다.
- Subclass만의 멤버들은 호출할 수 없다.
- 상위 클래스 객체를 하위 클래스에 대입할 수 없다.

부모 타입 포인터로 자식 객체를 참조했을 때 각 자식의 오버라이딩 된 멤버 함수를 호출하게 하려면 그 멤버 함수를 가상 함수(**virtual**)로 정의해야 한다.