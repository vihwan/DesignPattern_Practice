# Design Pattern 연습

## 명심하자!
항상 코드는 DRY하고 KISS하고 YAGNI하게..

DRY = Don't Repeat Yourself     - 특정 코드의 로직이 다양한 곳에서 반복되어 사용하지 마라.\
KISS = Keep In Simple, Stupid   - 코드는 항상 심플하고 멍청하게. 그리고 누구나 알아볼수 있게.\
YAGNI = You Ain't Gonna Need It - 지금 당장 필요없는 것을 미리 만들지 말자.

---------------------------------------------------------------

## Last Update

## 2022.01.23 (일)

1. 컴포넌트 패턴 - 상속 vs 컴포넌트

- 상속 : A is B

	- 부모 클래스로 부터 물려받은 부분은 다시 쓸 필요가 없기 때문에, 재사용 면에 있어서 효율적.
	- 부모 클래스가 될 공통된 필수 집합들을 개발자가 미리 예상하기가 힘들다.
	- 컴포넌트들끼리 커플링이 심하다. 만약 부모 클래스가 삭제 당하면 나머지 자식 클래스들에게 치명적인 문제들이 생긴다.
	
	Ex) 고블린은 몬스터이다. Is-A의 관계이므로 상속으로 만들어야한다.


- 컴포넌트 : A has B
	빈 컨테이너에 필요할 때 마다 원하는 기능을 갖다 붙여 포함시키는 방식. 일명 **부품**

	- 각자의 기능을 가지고 있는 스스로 동작하는 독립적인 부품.
	- 독립적인 클래스를 만들어 두고 만들어 둔 부품을 부품 붙이듯이 갖다 붙이면 된다.
	- 컴포넌트를 뗀다고 해서 오브젝트의 다른 컴포넌트에 영향이 가는 것은 없다. 가장 큰 장점
	- 코드의 의존성을 줄이고 재사용성을 높인다.

	Ex) 플레이어는 스테이터스를 가진다. Has-A의 관계. 컴포넌트로 구현하는 것이 좋다.

	- 그야말로 **유니티에서의 컴포넌트 동작 원리**

------------------------------------------------------

## 이전 개발 일지

### 2022.01.21 (금)

1. 레포지토리 생성 및 디자인 패턴의 시작

모든 디자인 패턴의 시작 => 하위 클래스를 상위 클래스 객체에 대입할 수 있다.
**다형성**이 핵심

```C#
Superclass obj = new Subclass();
/**********************************************/
Superclass obj1 = new Superclass();
Subclass obj2 = obj1;   // 컴파일 에러
```
- 부모 객체에 자식 클래스를 대입할 수 **있다.**
- 반대로 자식 객체에 부모 클래스를 대입할 수 **없다.**
- 이때 **obj**는 Subclass 타입의 객체를 참조하고 있지만, Superclass가 물려준 멤버들만 호출할 수 있다.
- Subclass만의 멤버들은 호출할 수 없다.
- 상위 클래스 객체를 하위 클래스에 대입할 수 없다.

부모 타입 포인터로 자식 객체를 참조했을 때 각 자식의 오버라이딩 된 멤버 함수를 호출하게 하려면 그 멤버 함수를 가상 함수(**virtual**)로 정의해야 한다.